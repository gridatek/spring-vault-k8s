# Spring Boot + HashiCorp Vault + Kubernetes Project

## Project Structure
```
spring-vault-k8s/
├── src/
│   ├── main/
│   │   ├── java/com/example/vaultapp/
│   │   │   ├── VaultApplication.java
│   │   │   ├── config/
│   │   │   │   ├── VaultConfig.java
│   │   │   │   └── DatabaseConfig.java
│   │   │   ├── controller/
│   │   │   │   └── HealthController.java
│   │   │   ├── entity/
│   │   │   │   └── User.java
│   │   │   ├── repository/
│   │   │   │   └── UserRepository.java
│   │   │   └── service/
│   │   │       └── UserService.java
│   │   └── resources/
│   │       ├── application.yml
│   │       └── bootstrap.yml
│   └── test/
│       └── java/com/example/vaultapp/
│           ├── VaultApplicationTests.java
│           ├── integration/
│           │   ├── DatabaseIntegrationTest.java
│           │   └── VaultIntegrationTest.java
│           └── e2e/
│               └── EndToEndTest.java
├── k8s/
│   ├── namespace.yaml
│   ├── vault-rbac.yaml
│   ├── app-deployment.yaml
│   ├── app-service.yaml
│   ├── postgres-deployment.yaml
│   ├── postgres-service.yaml
│   ├── postgres-pvc.yaml
│   └── vault-deployment.yaml
├── scripts/
│   ├── setup-vault.sh
│   ├── setup-k8s-auth.sh
│   └── generate-certs.sh
├── .github/workflows/
│   └── ci-cd.yml
├── docker-compose.yml
├── Dockerfile
├── pom.xml
└── mvnw, mvnw.cmd
```

---

## 1. Maven Configuration (pom.xml)
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>vault-app</artifactId>
    <version>1.0.0</version>
    <name>vault-app</name>
    <description>Spring Boot application with Vault integration</description>
    
    <properties>
        <java.version>17</java.version>
        <spring-cloud.version>2023.0.0</spring-cloud.version>
        <testcontainers.version>1.19.3</testcontainers.version>
    </properties>
    
    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        
        <!-- Spring Cloud Vault -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-vault-config</artifactId>
        </dependency>
        
        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <!-- Test Dependencies -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>vault</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <dependency>
                <groupId>org.testcontainers</groupId>
                <artifactId>testcontainers-bom</artifactId>
                <version>${testcontainers.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <configuration>
                    <includes>
                        <include>**/*Test.java</include>
                    </includes>
                    <excludes>
                        <exclude>**/integration/**</exclude>
                        <exclude>**/e2e/**</exclude>
                    </excludes>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-failsafe-plugin</artifactId>
                <configuration>
                    <includes>
                        <include>**/integration/**/*Test.java</include>
                        <include>**/e2e/**/*Test.java</include>
                    </includes>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>integration-test</goal>
                            <goal>verify</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>
```

---

## 2. Main Application Class
```java
// src/main/java/com/example/vaultapp/VaultApplication.java
package com.example.vaultapp;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class VaultApplication {
    public static void main(String[] args) {
        SpringApplication.run(VaultApplication.class, args);
    }
}
```

---

## 3. Configuration Classes

### Vault Configuration
```java
// src/main/java/com/example/vaultapp/config/VaultConfig.java
package com.example.vaultapp.config;

import org.springframework.cloud.vault.config.VaultProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.vault.authentication.ClientAuthentication;
import org.springframework.vault.authentication.KubernetesAuthentication;
import org.springframework.vault.authentication.KubernetesAuthenticationOptions;
import org.springframework.vault.client.VaultEndpoint;
import org.springframework.vault.core.VaultTemplate;
import org.springframework.vault.support.SslConfiguration;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

@Configuration
public class VaultConfig {

    @Bean
    public VaultTemplate vaultTemplate() throws IOException {
        VaultEndpoint endpoint = VaultEndpoint.create("vault", 8200);
        endpoint.setScheme("https");

        // SSL Configuration with PEM certificates
        SslConfiguration sslConfiguration = SslConfiguration.forTrustStore(
                Paths.get("/etc/ssl/certs/vault-ca.pem"),
                "changeit".toCharArray()
        );

        // Kubernetes Authentication
        String jwt = new String(Files.readAllBytes(
                Paths.get("/var/run/secrets/kubernetes.io/serviceaccount/token")
        ));
        
        KubernetesAuthenticationOptions options = KubernetesAuthenticationOptions.builder()
                .role("vault-app-role")
                .jwt(jwt)
                .path("kubernetes")
                .build();

        ClientAuthentication clientAuthentication = new KubernetesAuthentication(
                options, 
                VaultTemplate.create(endpoint, sslConfiguration).getVaultOperations()
        );

        return VaultTemplate.create(endpoint, sslConfiguration, clientAuthentication);
    }
}
```

### Database Configuration
```java
// src/main/java/com/example/vaultapp/config/DatabaseConfig.java
package com.example.vaultapp.config;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.sql.DataSource;

@Configuration
public class DatabaseConfig {

    @Value("${spring.datasource.url}")
    private String url;

    @Value("${spring.datasource.username}")
    private String username;

    @Value("${database.password}")
    private String password;

    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(url);
        config.setUsername(username);
        config.setPassword(password);
        config.setMaximumPoolSize(10);
        config.setMinimumIdle(2);
        return new HikariDataSource(config);
    }
}
```

---

## 4. Application Configuration

### Bootstrap Configuration
```yaml
# src/main/resources/bootstrap.yml
spring:
  application:
    name: vault-app
  cloud:
    vault:
      uri: https://vault:8200
      authentication: KUBERNETES
      kubernetes:
        role: vault-app-role
        kubernetes-path: kubernetes
        service-account-token-file: /var/run/secrets/kubernetes.io/serviceaccount/token
      ssl:
        trust-store: file:/etc/ssl/certs/vault-ca.pem
        trust-store-password: changeit
      kv:
        enabled: true
        backend: secret
        profile-separator: '/'
        default-context: vault-app
      config:
        order: -10
      fail-fast: true
      timeout: 5s
```

### Application Configuration
```yaml
# src/main/resources/application.yml
server:
  port: 8080

spring:
  datasource:
    url: jdbc:postgresql://postgres:5432/vaultapp
    username: vaultuser
    driver-class-name: org.postgresql.Driver
  
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: true

management:
  endpoints:
    web:
      exposure:
        include: health,info,prometheus,vault
  endpoint:
    health:
      show-details: always

logging:
  level:
    com.example.vaultapp: DEBUG
    org.springframework.vault: DEBUG
    org.springframework.cloud.vault: DEBUG
```

---

## 5. Entity, Repository, and Service

### User Entity
```java
// src/main/java/com/example/vaultapp/entity/User.java
package com.example.vaultapp.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotBlank
    private String name;
    
    @Email
    @Column(unique = true)
    private String email;
    
    // Constructors, getters, setters
    public User() {}
    
    public User(String name, String email) {
        this.name = name;
        this.email = email;
    }
    
    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}
```

### User Repository
```java
// src/main/java/com/example/vaultapp/repository/UserRepository.java
package com.example.vaultapp.repository;

import com.example.vaultapp.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
}
```

### User Service
```java
// src/main/java/com/example/vaultapp/service/UserService.java
package com.example.vaultapp.service;

import com.example.vaultapp.entity.User;
import com.example.vaultapp.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public List<User> findAll() {
        return userRepository.findAll();
    }
    
    public Optional<User> findById(Long id) {
        return userRepository.findById(id);
    }
    
    public User save(User user) {
        return userRepository.save(user);
    }
    
    public void deleteById(Long id) {
        userRepository.deleteById(id);
    }
}
```

---

## 6. Controller
```java
// src/main/java/com/example/vaultapp/controller/HealthController.java
package com.example.vaultapp.controller;

import com.example.vaultapp.entity.User;
import com.example.vaultapp.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api")
public class HealthController {
    
    @Autowired
    private UserService userService;
    
    @Value("${database.password:NOT_SET}")
    private String dbPassword;
    
    @GetMapping("/health")
    public ResponseEntity<Map<String, Object>> health() {
        return ResponseEntity.ok(Map.of(
            "status", "UP",
            "database", "Connected",
            "vault", dbPassword.equals("NOT_SET") ? "NOT_CONFIGURED" : "CONFIGURED"
        ));
    }
    
    @GetMapping("/users")
    public List<User> getUsers() {
        return userService.findAll();
    }
    
    @PostMapping("/users")
    public User createUser(@RequestBody User user) {
        return userService.save(user);
    }
    
    @GetMapping("/users/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        return userService.findById(id)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }
}
```

---

## 7. Dockerfile
```dockerfile
FROM openjdk:17-jdk-slim as builder

WORKDIR /app
COPY mvnw .
COPY .mvn .mvn
COPY pom.xml .
RUN ./mvnw dependency:go-offline -B

COPY src src
RUN ./mvnw package -DskipTests

FROM openjdk:17-jre-slim

RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY --from=builder /app/target/*.jar app.jar

# Create directories for certificates
RUN mkdir -p /etc/ssl/certs

EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/api/health || exit 1

ENTRYPOINT ["java", "-jar", "app.jar"]
```

---

## 8. Kubernetes Manifests

### Namespace
```yaml
# k8s/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: vault-app
```

### Vault RBAC
```yaml
# k8s/vault-rbac.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-app
  namespace: vault-app
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: vault-app-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:auth-delegator
subjects:
- kind: ServiceAccount
  name: vault-app
  namespace: vault-app
---
apiVersion: v1
kind: Secret
metadata:
  name: vault-ca-cert
  namespace: vault-app
type: Opaque
data:
  vault-ca.pem: LS0tLS1CRUdJTi... # Base64 encoded CA certificate
```

### PostgreSQL Deployment
```yaml
# k8s/postgres-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
  namespace: vault-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:15
        env:
        - name: POSTGRES_DB
          value: vaultapp
        - name: POSTGRES_USER
          value: vaultuser
        - name: POSTGRES_PASSWORD
          value: temppassword
        ports:
        - containerPort: 5432
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
      volumes:
      - name: postgres-storage
        persistentVolumeClaim:
          claimName: postgres-pvc
```

### App Deployment
```yaml
# k8s/app-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: vault-app
  namespace: vault-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: vault-app
  template:
    metadata:
      labels:
        app: vault-app
    spec:
      serviceAccountName: vault-app
      containers:
      - name: vault-app
        image: vault-app:latest
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: kubernetes
        volumeMounts:
        - name: vault-ca-cert
          mountPath: /etc/ssl/certs
          readOnly: true
        livenessProbe:
          httpGet:
            path: /api/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /api/health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
      volumes:
      - name: vault-ca-cert
        secret:
          secretName: vault-ca-cert
```

---

## 9. Docker Compose
```yaml
# docker-compose.yml
version: '3.8'

services:
  vault:
    image: vault:1.15.2
    container_name: vault
    restart: unless-stopped
    ports:
      - "8200:8200"
    environment:
      VAULT_DEV_ROOT_TOKEN_ID: myroot
      VAULT_DEV_LISTEN_ADDRESS: 0.0.0.0:8200
      VAULT_ADDR: http://0.0.0.0:8200
    cap_add:
      - IPC_LOCK
    volumes:
      - vault_data:/vault/data
      - ./scripts:/scripts
    command: >
      sh -c "vault server -dev -dev-listen-address=0.0.0.0:8200 &
             sleep 10 &&
             /scripts/setup-vault.sh &&
             wait"

  postgres:
    image: postgres:15
    container_name: postgres
    restart: unless-stopped
    ports:
      - "5432:5432"
    environment:
      POSTGRES_DB: vaultapp
      POSTGRES_USER: vaultuser
      POSTGRES_PASSWORD: secretpassword
    volumes:
      - postgres_data:/var/lib/postgresql/data

  app:
    build: .
    container_name: vault-app
    restart: unless-stopped
    ports:
      - "8080:8080"
    environment:
      SPRING_PROFILES_ACTIVE: local
      SPRING_CLOUD_VAULT_URI: http://vault:8200
      SPRING_CLOUD_VAULT_TOKEN: myroot
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/vaultapp
    depends_on:
      - vault
      - postgres
    volumes:
      - ./scripts:/scripts

volumes:
  vault_data:
  postgres_data:
```

---

## 10. GitHub Actions Workflow
```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Cache Maven packages
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2
    
    - name: Run unit tests
      run: ./mvnw clean test
    
    - name: Run integration tests
      run: ./mvnw clean verify -P integration-tests

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Build application
      run: ./mvnw clean package -DskipTests
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Kind cluster
      uses: helm/kind-action@v1.8.0
      with:
        cluster_name: vault-app-cluster
    
    - name: Load Docker image to Kind
      run: |
        docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        kind load docker-image ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} --name vault-app-cluster
    
    - name: Deploy to Kubernetes
      run: |
        kubectl apply -f k8s/
        kubectl set image deployment/vault-app vault-app=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} -n vault-app
        kubectl rollout status deployment/vault-app -n vault-app
    
    - name: Run end-to-end tests
      run: |
        kubectl port-forward service/vault-app 8080:8080 -n vault-app &
        sleep 30
        curl -f http://localhost:8080/api/health
```

---

## 11. Test Classes

### Unit Tests
```java
// src/test/java/com/example/vaultapp/VaultApplicationTests.java
package com.example.vaultapp;

import com.example.vaultapp.controller.HealthController;
import com.example.vaultapp.service.UserService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.context.ActiveProfiles;

import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest
@ActiveProfiles("test")
class VaultApplicationTests {

    @Autowired
    private HealthController healthController;

    @MockBean
    private UserService userService;

    @Test
    void contextLoads() {
        assertThat(healthController).isNotNull();
    }
}
```

### Integration Tests
```java
// src/test/java/com/example/vaultapp/integration/DatabaseIntegrationTest.java
package com.example.vaultapp.integration;

import com.example.vaultapp.entity.User;
import com.example.vaultapp.repository.UserRepository;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import static org.assertj.core.api.Assertions.assertThat;

@DataJpaTest
@Testcontainers
public class DatabaseIntegrationTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");

    @DynamicPropertySource
    static void properties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }

    @Autowired
    private UserRepository userRepository;

    @Test
    void testUserPersistence() {
        User user = new User("John Doe", "john@example.com");
        User saved = userRepository.save(user);
        
        assertThat(saved.getId()).isNotNull();
        assertThat(saved.getName()).isEqualTo("John Doe");
        assertThat(saved.getEmail()).isEqualTo("john@example.com");
    }
}
```

---

## 12. Setup Scripts

### Vault Setup Script
```bash
#!/bin/bash
# scripts/setup-vault.sh

export VAULT_ADDR=http://localhost:8200
export VAULT_TOKEN=myroot

# Enable KV secrets engine
vault secrets enable -path=secret kv-v2

# Create database password secret
vault kv put secret/vault-app database.password=supersecretpassword

echo "Vault setup completed successfully!"
```

### Certificate Generation Script
```bash
#!/bin/bash
# scripts/generate-certs.sh

# Generate CA private key
openssl genrsa -out ca-key.pem 4096

# Generate CA certificate
openssl req -new -x509 -key ca-key.pem -out ca-cert.pem -days 365 -subj "/CN=Vault CA"

# Generate Vault private key
openssl genrsa -out vault-key.pem 4096

# Generate Vault certificate signing request
openssl req -new -key vault-key.pem -out vault-csr.pem -subj "/CN=vault"

# Generate Vault certificate
openssl x509 -req -in vault-csr.pem -CA ca-cert.pem -CAkey ca-key.pem -CAcreateserial -out vault-cert.pem -days 365

echo "Certificates generated successfully!"
```

---

## Setup Instructions

1. **Clone and Initialize:**
   ```bash
   git clone <repository-url>
   cd spring-vault-k8s
   chmod +x mvnw
   ```

2. **Local Development with Docker Compose:**
   ```bash
   chmod +x scripts/*.sh
   docker-compose up -d
   ```

3. **Kubernetes Deployment:**
   ```bash
   # Create Kind cluster
   kind create cluster --name vault-app-cluster
   
   # Build and load image
   docker build -t vault-app:latest .
   kind load docker-image vault-app:latest --name vault-app-cluster
   
   # Deploy application
   kubectl apply -f k8s/
   ```

4. **Testing:**
   ```bash
   # Unit tests
   ./mvnw test
   
   # Integration tests
   ./mvnw verify
   
   # End-to-end test
   curl http://localhost:8080/api/health
   ```

This complete setup provides a production-ready Spring Boot application with secure Vault integration, comprehensive testing, and automated CI/CD deployment to Kubernetes.